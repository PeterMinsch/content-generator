# Story 8.2: Block Order Customization during CSV Import

**Epic:** 8 - Internal Linking & Content Network
**Status:** Draft

---

## Story

**As a** content manager,
**I want** to customize the order of content blocks during CSV import,
**so that** I can control the structure and flow of pages based on content strategy without manual reordering

---

## Acceptance Criteria

1. **CSV Import UI - Block Ordering Step**
   - After column mapping validation, user sees "Step 3: Customize Block Order"
   - Interface displays all 12 blocks in default order with drag handles
   - User can drag-and-drop blocks to reorder
   - "Use this order for all pages in this import" checkbox is selected by default
   - "Reset to Default Order" button restores original sequence
   - "Proceed with Import" button advances to batch import

2. **Block Order Storage**
   - Custom block order saved as post meta `_seo_block_order` (JSON array)
   - Each imported post receives the custom order from import session
   - If no custom order specified, posts use default hardcoded order

3. **Generation Respects Custom Order**
   - When generating content (manual or queue), system reads `_seo_block_order`
   - Blocks generate in custom order instead of default order
   - Falls back to default order if meta doesn't exist

4. **Admin UI - Edit Page**
   - No UI changes needed (custom order is internal to generation)
   - Blocks display in ACF field order (unchanged)
   - Generation happens in custom order behind the scenes

5. **Performance**
   - Block ordering UI loads instantly (<100ms)
   - No impact on import processing time
   - No impact on generation time

---

## Tasks / Subtasks

- [ ] **Task 1: Add Block Ordering Step to CSV Import UI** (AC: 1)
  - [ ] Create new section in `templates/admin/import.php` after column mapping
  - [ ] Add `<div id="block-ordering-section" style="display: none;">` with sortable list
  - [ ] Display all 12 blocks with labels and descriptions from `config/block-definitions.php`
  - [ ] Add drag handles (⋮⋮ icon) to each block item
  - [ ] Add "Use this order for all pages" checkbox (checked by default)
  - [ ] Add "Reset to Default Order" button
  - [ ] Add "Proceed with Import" button to trigger AJAX save and continue

- [ ] **Task 2: Implement Drag-and-Drop JavaScript** (AC: 1)
  - [ ] Create `assets/js/src/block-ordering.js`
  - [ ] Integrate SortableJS library (https://sortablejs.github.io/Sortable/)
  - [ ] Initialize Sortable on block list with animation and handle
  - [ ] Implement "Reset to Default Order" button handler
  - [ ] Extract block order array on "Proceed with Import" click
  - [ ] Validate all 13 blocks present before proceeding

- [ ] **Task 3: Create AJAX Handler for Block Order Storage** (AC: 1)
  - [ ] Add `ajaxSaveBlockOrder()` method to `includes/Admin/ImportPage.php`
  - [ ] Validate incoming block order array (all 13 blocks present)
  - [ ] Store block order in transient: `csv_import_block_order_{user_id}`
  - [ ] Return success/error response
  - [ ] Hook action: `wp_ajax_seo_save_block_order`

- [ ] **Task 4: Update ImportService to Save Block Order** (AC: 2)
  - [ ] Add `$custom_block_order` property to `includes/Services/ImportService.php`
  - [ ] Accept `custom_block_order` in constructor options
  - [ ] In `saveMetadata()`, save block order as post meta: `update_post_meta($post_id, '_seo_block_order', json_encode($custom_block_order))`
  - [ ] Only save if `$custom_block_order` is not empty

- [ ] **Task 5: Update ContentGenerationService to Read Custom Order** (AC: 3)
  - [ ] Add `getBlockOrder()` private method to `includes/Services/ContentGenerationService.php`
  - [ ] Method reads `_seo_block_order` post meta
  - [ ] If exists and valid, return decoded array
  - [ ] If not exists, return `self::BLOCK_ORDER` constant (default)
  - [ ] Update `generateAllBlocks()` to use `$this->getBlockOrder($post_id)` instead of `self::BLOCK_ORDER`

- [ ] **Task 6: Wire Up CSV Import Workflow** (AC: 1)
  - [ ] Update `assets/js/src/column-mapping.js` to show block ordering section after validation
  - [ ] After block order saved via AJAX, proceed to batch import
  - [ ] Pass block order from transient to ImportService constructor
  - [ ] Clear transient after import completes

- [ ] **Task 7: Add Block Order UI Enhancements** (AC: 1, 5)
  - [ ] Style sortable list with proper spacing and hover effects
  - [ ] Add smooth drag animation (150ms)
  - [ ] Show visual feedback during drag (ghost element)
  - [ ] Add block descriptions/tooltips for clarity
  - [ ] Ensure mobile-friendly touch support

- [ ] **Task 8: Testing** (AC: All)
  - [ ] Unit test `getBlockOrder()` returns custom order when meta exists
  - [ ] Unit test `getBlockOrder()` returns default when meta doesn't exist
  - [ ] Unit test block order validation (all 13 blocks required)
  - [ ] Integration test: Import CSV with custom order, verify post meta saved
  - [ ] Integration test: Generate content, verify blocks generated in custom order
  - [ ] Manual test: Drag blocks, verify order changes
  - [ ] Manual test: Reset button restores default order
  - [ ] Manual test: Import 10 pages, verify all have same custom order

---

## Dev Notes

### Feature Context

This story extends Epic 6 (CSV Import) by adding a block ordering capability. Currently, all pages generate content blocks in the same fixed order (seo_metadata → hero → serp_answer → ... → cta). This feature allows users to customize the block order during CSV import, giving them control over page structure.

**From Claude's Analysis:**
- Blocks are already independent and self-contained in `config/block-definitions.php`
- Each block has an `order` property (1-12) but it's currently unused
- Generation is already sequential in `ContentGenerationService.php:528`
- The hardcoded `BLOCK_ORDER` constant just needs to become dynamic

### Previous Story Insights

From Story 6.4 (Batch Page Creation):
- ImportService already handles batch creation with metadata storage
- Post meta is the correct storage mechanism for per-page settings
- CSV import uses transients to pass data between multi-step workflow

From Story 8.1 (Automated Internal Linking):
- Similar pattern: post meta stores custom configuration per page
- Generation services read meta and fall back to defaults
- No schema changes needed (uses existing wp_postmeta)

### Data Models

**Block Order Storage (Post Meta)**
```php
// Stored in wp_postmeta
meta_key: '_seo_block_order'
meta_value: '["seo_metadata","hero","faqs","cta","serp_answer",..."]' // JSON array of 13 block keys
```

**Block Order Transient (Import Session)**
```php
// Stored during import workflow
transient_key: 'csv_import_block_order_123' // {user_id}
transient_value: [
    'order' => ['seo_metadata', 'hero', 'faqs', ...],
    'apply_to_all' => true
]
expiration: 1 hour
```

**Default Block Order (Constant)**
From `includes/Services/ContentGenerationService.php:26-40`:
```php
private const BLOCK_ORDER = [
    'seo_metadata',
    'hero',
    'serp_answer',
    'product_criteria',
    'materials',
    'process',
    'comparison',
    'product_showcase',
    'size_fit',
    'care_warranty',
    'ethics',
    'faqs',
    'cta',
];
```

[Source: ContentGenerationService.php:26-40]

### Plugin Architecture & Patterns

**Multi-Step Form Pattern (CSV Import)**
The CSV import already uses a 3-step workflow [Source: epic-6-csv-import.md]:
1. Upload CSV
2. Map Columns
3. Import (NEW: Add Block Ordering before this step)

**Transient Storage for Session Data**
WordPress transients are used to pass data between steps [Source: architecture.md#Architectural Patterns]:
- `csv_import_mapping_{user_id}` - Column mappings
- `csv_import_file_path_{user_id}` - Uploaded file path
- `csv_import_block_order_{user_id}` - Block order (NEW)

**Service Layer Pattern**
Generation and import are handled by service classes [Source: architecture.md#Service Layer Pattern]:
- `ImportService.php` - Creates posts with metadata
- `ContentGenerationService.php` - Generates blocks in sequence
- Both services need minimal updates for this feature

### File Locations

Based on Unified Project Structure [Source: architecture.md#Unified Project Structure]:

**PHP Classes:**
- Update: `includes/Services/ImportService.php` (lines 94-100, 268)
- Update: `includes/Services/ContentGenerationService.php` (lines 26-40, 509-616)
- Update: `includes/Admin/ImportPage.php` (add AJAX handler)

**Templates:**
- Update: `templates/admin/import.php` (add block ordering UI after line ~105)

**JavaScript:**
- New: `assets/js/src/block-ordering.js` (drag-drop component)
- Update: `assets/js/src/column-mapping.js` (workflow integration)

**Configuration:**
- Reference: `config/block-definitions.php` (block labels and descriptions)

### Component Specifications

**Block Ordering UI Component**
Location: `templates/admin/import.php` (new section)

HTML Structure:
```html
<div id="block-ordering-section" style="display: none;">
    <h3>Step 3: Customize Block Order</h3>
    <p>Drag blocks to reorder how content will be generated:</p>

    <ul id="sortable-blocks" class="seo-sortable-list">
        <li data-block="hero">
            <span class="drag-handle">⋮⋮</span>
            <div class="block-info">
                <strong>Hero Section</strong>
                <span class="block-desc">Main banner with title and image</span>
            </div>
        </li>
        <!-- Repeat for all 12 blocks -->
    </ul>

    <label class="seo-checkbox">
        <input type="checkbox" id="apply-order-to-all" checked>
        Use this order for all pages in this import
    </label>

    <div class="block-ordering-actions">
        <button id="reset-order-btn" class="seo-btn-secondary">Reset to Default Order</button>
        <button id="proceed-import-btn" class="seo-btn-primary">Proceed with Import</button>
    </div>
</div>
```

**JavaScript Component (SortableJS Integration)**
Location: `assets/js/src/block-ordering.js`

```javascript
import Sortable from 'sortablejs';

// Initialize sortable list
const sortableList = document.getElementById('sortable-blocks');
const sortable = Sortable.create(sortableList, {
    animation: 150,
    handle: '.drag-handle',
    ghostClass: 'seo-sortable-ghost',
    dragClass: 'seo-sortable-drag'
});

// Get current block order
function getBlockOrder() {
    return Array.from(sortableList.children).map(li => li.dataset.block);
}

// Reset to default order
document.getElementById('reset-order-btn').addEventListener('click', () => {
    // Restore default order from data attribute
    sortable.sort(defaultOrder);
});

// Proceed with import
document.getElementById('proceed-import-btn').addEventListener('click', async () => {
    const blockOrder = getBlockOrder();
    const applyToAll = document.getElementById('apply-order-to-all').checked;

    // Validate all blocks present
    if (blockOrder.length !== 13) {
        alert('Invalid block order. Please refresh the page.');
        return;
    }

    // Save via AJAX
    const response = await wp.apiFetch({
        path: '/seo-generator/v1/import/block-order',
        method: 'POST',
        data: { blockOrder, applyToAll }
    });

    if (response.success) {
        // Continue to import step
        startBatchImport();
    }
});
```

[Source: Claude's Technical Analysis - Part 3]

### API Specifications

**New AJAX Endpoint**
Action: `wp_ajax_seo_save_block_order`
Handler: `ImportPage::ajaxSaveBlockOrder()`

Request:
```json
{
    "action": "seo_save_block_order",
    "nonce": "abc123...",
    "block_order": ["seo_metadata", "hero", "faqs", ...],
    "apply_to_all": true
}
```

Response (Success):
```json
{
    "success": true,
    "data": {
        "message": "Block order saved successfully"
    }
}
```

Response (Error):
```json
{
    "success": false,
    "data": {
        "message": "Invalid block order: missing blocks"
    }
}
```

[Source: Claude's Technical Analysis - Part 4]

### Technical Constraints

**Block Order Validation**
All 13 blocks must be present in custom order:
- `seo_metadata`, `hero`, `serp_answer`, `product_criteria`, `materials`
- `process`, `comparison`, `product_showcase`, `size_fit`, `care_warranty`
- `ethics`, `faqs`, `cta`

Missing or extra blocks should trigger validation error.

**Backward Compatibility**
Pages generated before this feature won't have `_seo_block_order` meta. The `getBlockOrder()` method must gracefully fall back to the default constant.

**WordPress Coding Standards**
Follow WordPress PHP Coding Standards for all PHP changes [Source: architecture.md#Tech Stack - Code Quality (PHP)]:
- Use `wp_kses()` for HTML output
- Use `wp_json_encode()` instead of `json_encode()`
- Proper nonce verification for AJAX

**JavaScript Standards**
Use WordPress JavaScript conventions [Source: architecture.md#Tech Stack - Code Quality (JS)]:
- Use `wp.apiFetch` for AJAX calls (not jQuery.ajax)
- Follow `@wordpress/eslint-plugin` rules
- Use ES6+ syntax (arrow functions, const/let, template literals)

### Integration Points

**Hook 1: Column Mapping Completion**
Location: `assets/js/src/column-mapping.js` after successful validation

```javascript
// After validateMapping() succeeds
if (mappingValid) {
    // Hide column mapping section
    document.getElementById('column-mapping-section').style.display = 'none';

    // Show block ordering section (NEW)
    document.getElementById('block-ordering-section').style.display = 'block';
}
```

**Hook 2: Import Service Constructor**
Location: `includes/Admin/ImportPage.php` AJAX import handler

```php
// Retrieve block order from transient
$block_order_data = get_transient('csv_import_block_order_' . get_current_user_id());
$custom_block_order = $block_order_data['order'] ?? null;

// Pass to ImportService
$import_service = new ImportService([
    'batch_size' => 10,
    'check_duplicates' => true,
    'generation_mode' => $generation_mode,
    'custom_block_order' => $custom_block_order  // NEW
]);
```

**Hook 3: Content Generation**
Location: `includes/Services/ContentGenerationService.php:509-616`

```php
// In generateAllBlocks() method
public function generateAllBlocks( int $post_id ): BulkGenerationResult {
    // ... existing code ...

    // Get custom block order if exists (MODIFIED)
    $block_order = $this->getBlockOrder($post_id);

    // Process each block sequentially (MODIFIED LOOP)
    foreach ( $block_order as $index => $block_type ) {
        // ... existing generation logic ...
    }
}
```

[Source: ContentGenerationService.php:509-616]

### Project Structure Notes

The plugin follows WordPress Plugin Architecture with MVC-inspired separation [Source: architecture.md#Plugin Architecture]. All new files follow established patterns:
- Service classes in `includes/Services/`
- Admin controllers in `includes/Admin/`
- Frontend JavaScript in `assets/js/src/`
- Build output in `assets/js/build/`

No new database tables required - uses existing `wp_postmeta`.

---

## Testing

### Testing Standards

**Framework:** PHPUnit 9.x for PHP unit and integration tests [Source: architecture.md#Tech Stack - Backend Testing]

**Test Location:**
- Unit tests: `tests/php/Services/ContentGenerationServiceTest.php` (update existing)
- Unit tests: `tests/php/Services/ImportServiceTest.php` (update existing)
- Integration tests: `tests/php/Integration/BlockOrderingTest.php` (new)

**Standards:** Follow WordPress test framework patterns with mocking for unit tests [Source: architecture.md#Testing Strategy]

**Coverage:** Test block order retrieval, validation, storage, and generation sequence

### Test Cases

**Unit Test: getBlockOrder() Returns Custom Order**
```php
public function test_get_block_order_returns_custom_order_when_meta_exists() {
    $service = new ContentGenerationService(...);
    $post_id = $this->factory->post->create(['post_type' => 'seo-page']);

    $custom_order = ['hero', 'faqs', 'cta', 'seo_metadata', ...];
    update_post_meta($post_id, '_seo_block_order', wp_json_encode($custom_order));

    $result = $this->callPrivateMethod($service, 'getBlockOrder', [$post_id]);

    $this->assertEquals($custom_order, $result);
}
```

**Unit Test: getBlockOrder() Returns Default When Meta Missing**
```php
public function test_get_block_order_returns_default_when_no_meta() {
    $service = new ContentGenerationService(...);
    $post_id = $this->factory->post->create(['post_type' => 'seo-page']);

    $result = $this->callPrivateMethod($service, 'getBlockOrder', [$post_id]);

    $this->assertEquals(ContentGenerationService::BLOCK_ORDER, $result);
}
```

**Integration Test: Block Order Saved During Import**
```php
public function test_import_saves_custom_block_order_to_post_meta() {
    $custom_order = ['hero', 'faqs', 'cta', ...];

    $import_service = new ImportService([
        'custom_block_order' => $custom_order
    ]);

    $rows = [['Page Title', 'focus keyword', 'topic']];
    $result = $import_service->processSingleBatch($rows, $headers, $mapping);

    $post_id = $result['created'][0]['post_id'];
    $saved_order = json_decode(get_post_meta($post_id, '_seo_block_order', true), true);

    $this->assertEquals($custom_order, $saved_order);
}
```

**Manual QA Test: Drag-and-Drop Block Ordering**
- [ ] Load CSV import page
- [ ] Upload CSV and map columns
- [ ] Proceed to block ordering step
- [ ] Drag "FAQs" block to position 3
- [ ] Drag "CTA" block to position 4
- [ ] Click "Proceed with Import"
- [ ] Verify AJAX request sent with custom order
- [ ] Verify import completes successfully
- [ ] Check created page has `_seo_block_order` meta with custom order
- [ ] Manually generate content for page
- [ ] Verify blocks generated in custom order (check debug.log timestamps)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-15 | 1.0 | Initial story creation | Bob (Scrum Master) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*To be completed by Dev Agent*

### Debug Log References

*To be completed by Dev Agent*

### Completion Notes List

*To be completed by Dev Agent*

### File List

*To be completed by Dev Agent*

---

## QA Results

*This section will be populated by the QA Agent after testing*
