# Story 2.3: Build Single Block Generation REST API Endpoint

## Status

Ready for Review

## Story

**As a** content manager,
**I want** to generate content for a single block via API,
**so that** I can regenerate individual blocks without affecting others

## Acceptance Criteria

1. REST endpoint registered: `POST /wp-json/seo-generator/v1/pages/{id}/generate`
2. Endpoint accepts parameters:
   - `blockType` (required): which block to generate
   - `context` (optional): additional context data
3. Endpoint performs validation:
   - Post ID exists and is type `seo-page`
   - Block type is valid (one of 12 blocks)
   - User has `edit_posts` capability
   - Nonce verification passes
4. Generation workflow:
   - Build full context (page title, topic, focus keyword, page type)
   - Render prompt using PromptTemplateEngine
   - Call OpenAIService to generate content
   - Parse and validate generated content
   - Save content to ACF fields
   - Log generation to database
   - Return success response with generated content and metadata
5. Error handling returns appropriate HTTP status codes and messages
6. Response includes: generated content, tokens used, cost, generation time

## Tasks / Subtasks

- [ ] Task 1: Create REST API controller (AC: 1, 2, 3)
  - [ ] Create file `includes/Controllers/GenerationController.php`
  - [ ] Implement namespace `SEOGenerator\Controllers`
  - [ ] Extend `WP_REST_Controller` class
  - [ ] Register REST route in `register_routes()` method
  - [ ] Route: `POST /seo-generator/v1/pages/(?P<id>\d+)/generate`
  - [ ] Implement permission callback checking `edit_posts` capability
  - [ ] Add nonce verification in permission callback
  - [ ] Implement `generate_block()` callback method
  - [ ] Validate post ID exists and is `seo-page` type
  - [ ] Validate blockType parameter is one of 12 valid blocks
  - [ ] Return WP_Error for validation failures with appropriate status codes
  - [ ] Accept optional context parameter

- [ ] Task 2: Create ContentGenerationService (AC: 4, 6)
  - [ ] Create file `includes/Services/ContentGenerationService.php`
  - [ ] Implement namespace `SEOGenerator\Services`
  - [ ] Inject dependencies: OpenAIService, PromptTemplateEngine, CostTrackingService (Story 2.5)
  - [ ] Create `generateSingleBlock($postId, $blockType, $context)` method
  - [ ] Build full context using PromptTemplateEngine->buildContext()
  - [ ] Render prompt using PromptTemplateEngine->renderPrompt()
  - [ ] Record start time for generation time tracking
  - [ ] Call OpenAIService->generateContent()
  - [ ] Parse generated content based on block type
  - [ ] Validate generated content meets requirements (length, format)
  - [ ] Save content to ACF fields using `update_field()`
  - [ ] Calculate generation time (end time - start time)
  - [ ] Calculate cost using token usage
  - [ ] Return structured response with content, tokens, cost, time

- [ ] Task 3: Implement block-specific content parsing (AC: 4)
  - [ ] Create `BlockContentParser` helper class in `includes/Services/`
  - [ ] Implement `parse($blockType, $rawContent)` method
  - [ ] Parse simple text blocks (hero, serp_answer, etc.)
  - [ ] Parse repeater fields (answer_bullets, criteria_items, etc.)
  - [ ] Parse JSON-structured responses from AI
  - [ ] Handle parsing errors gracefully
  - [ ] Validate parsed data structure matches ACF field schema
  - [ ] Return parsed data ready for ACF update

- [ ] Task 4: Implement ACF field updater (AC: 4)
  - [ ] Create method `updateACFFields($postId, $blockType, $parsedContent)` in ContentGenerationService
  - [ ] Map block types to ACF field names
  - [ ] Handle simple fields (text, textarea)
  - [ ] Handle repeater fields (convert arrays to ACF repeater format)
  - [ ] Handle image fields (if applicable)
  - [ ] Use `update_field()` for each field
  - [ ] Verify fields saved successfully
  - [ ] Update generation status meta (mark as "generated")
  - [ ] Store timestamp of generation

- [ ] Task 5: Implement error handling with status codes (AC: 5)
  - [ ] Return 400 Bad Request for invalid block type
  - [ ] Return 404 Not Found for non-existent post ID
  - [ ] Return 403 Forbidden for permission failures
  - [ ] Return 429 Too Many Requests for rate limit errors
  - [ ] Return 500 Internal Server Error for OpenAI failures
  - [ ] Return 503 Service Unavailable for budget exceeded
  - [ ] Include user-friendly error messages
  - [ ] Log all errors to debug.log with full context
  - [ ] Use custom exception classes from Story 2.1

- [ ] Task 6: Format REST API response (AC: 6)
  - [ ] Create response structure with WP_REST_Response
  - [ ] Include generated content (all fields for block)
  - [ ] Include promptTokens, completionTokens, totalTokens
  - [ ] Include calculated cost in USD
  - [ ] Include generationTime in seconds
  - [ ] Include model used
  - [ ] Include timestamp
  - [ ] Return status code 200 for success

- [ ] Task 7: Integrate with Plugin initialization
  - [ ] Register GenerationController in Plugin.php
  - [ ] Initialize ContentGenerationService with dependencies
  - [ ] Add action hook for REST API initialization
  - [ ] Ensure services loaded before REST routes registered

- [ ] Task 8: Write integration tests (AC: 1-6)
  - [ ] Create test file `tests/php/Controllers/GenerationControllerTest.php`
  - [ ] Test successful single block generation
  - [ ] Test endpoint validation (post exists, block type valid)
  - [ ] Test permission checks (user capabilities)
  - [ ] Test error responses (400, 403, 404, 429, 500)
  - [ ] Mock OpenAI service responses
  - [ ] Verify ACF fields updated correctly
  - [ ] Verify response format includes all required data
  - [ ] Test with all 12 block types

## Dev Notes

### Relevant Architecture Context

**Tech Stack:**
- PHP: 8.0+
- WordPress: 6.0+ with REST API
- ACF: 6.0+ Free for field management
[Source: architecture.md#tech-stack]

**Project Structure:**
```
includes/
├── Controllers/
│   └── GenerationController.php
├── Services/
│   ├── ContentGenerationService.php
│   └── BlockContentParser.php
└── Plugin.php
```
[Source: architecture.md#unified-project-structure]

**REST API Configuration:**
- Base URL: `/wp-json/seo-generator/v1`
- Authentication: WordPress nonce via X-WP-Nonce header
- Permission: `edit_posts` capability required
[Source: architecture.md#api-specification]

**Controller Pattern:**
REST API controllers are thin orchestrators that delegate to services:
```php
class GenerationController extends WP_REST_Controller {
    public function register_routes() {
        register_rest_route('seo-generator/v1', '/pages/(?P<id>\d+)/generate', [
            'methods' => 'POST',
            'callback' => [$this, 'generate_block'],
            'permission_callback' => [$this, 'check_permission'],
            'args' => [
                'blockType' => [
                    'required' => true,
                    'type' => 'string',
                    'enum' => ['hero', 'serp_answer', 'product_criteria', ...],
                ],
                'context' => [
                    'required' => false,
                    'type' => 'object',
                ],
            ],
        ]);
    }

    public function generate_block(WP_REST_Request $request) {
        try {
            $result = $this->generationService->generateSingleBlock(
                $request['id'],
                $request['blockType'],
                $request['context'] ?? []
            );
            return new WP_REST_Response($result, 200);
        } catch (RateLimitException $e) {
            return new WP_Error('rate_limit_exceeded', $e->getMessage(), ['status' => 429]);
        }
    }
}
```
[Source: architecture.md#plugin-architecture]

**Generation Flow (from PRD):**
1. User clicks "Generate" button
2. AJAX request with nonce verification
3. Retrieve prompt template
4. Replace variables with context
5. Call OpenAI API via wp_remote_post()
6. Parse response
7. Validate output
8. Return via wp_send_json_success()
9. JavaScript populates field(s)
10. Update status indicator
[Source: PRD prd.md#generation-flow]

**12 Valid Block Types:**
```php
private const VALID_BLOCKS = [
    'hero',
    'serp_answer',
    'product_criteria',
    'materials',
    'process',
    'comparison',
    'product_showcase',
    'size_fit',
    'care_warranty',
    'ethics',
    'faqs',
    'cta',
];
```
[Source: PRD prd.md#content-structure-12-acf-block-groups]

**Block to ACF Field Mapping Example:**
```php
private const BLOCK_FIELD_MAP = [
    'hero' => ['hero_title', 'hero_subtitle', 'hero_summary', 'hero_image'],
    'serp_answer' => ['answer_heading', 'answer_paragraph', 'answer_bullets'],
    'product_criteria' => ['criteria_heading', 'criteria_items'],
    // ... rest of blocks
];
```
[Source: PRD prd.md#content-structure-12-acf-block-groups]

**ACF Field Update:**
```php
// Simple field
update_field('hero_title', $value, $post_id);

// Repeater field
$rows = [
    ['bullet_text' => 'First bullet'],
    ['bullet_text' => 'Second bullet'],
];
update_field('answer_bullets', $rows, $post_id);
```
[Source: PRD prd.md#appendix]

**Cost Calculation:**
- GPT-4 Turbo pricing:
  - Prompt tokens: $0.01 per 1K tokens
  - Completion tokens: $0.03 per 1K tokens
- Formula: `($promptTokens / 1000 * 0.01) + ($completionTokens / 1000 * 0.03)`
[Source: PRD prd.md#cost-tracking]

**Error Response Format:**
```php
return new WP_Error(
    'invalid_block_type',
    'Block type "invalid" is not supported. Valid blocks: hero, serp_answer, ...',
    ['status' => 400]
);
```
[Source: architecture.md#api-specification]

**Success Response Format:**
```json
{
  "success": true,
  "data": {
    "content": {
      "hero_title": "Generated title",
      "hero_subtitle": "Generated subtitle",
      "hero_summary": "Generated summary..."
    },
    "metadata": {
      "promptTokens": 120,
      "completionTokens": 250,
      "totalTokens": 370,
      "cost": 0.0087,
      "generationTime": 3.45,
      "model": "gpt-4-turbo-preview",
      "timestamp": "2025-01-07T10:30:00Z"
    }
  }
}
```
[Source: architecture.md#api-specification]

**Permission Callback Example:**
```php
public function check_permission(WP_REST_Request $request) {
    // Check nonce
    if (!wp_verify_nonce($request->get_header('X-WP-Nonce'), 'wp_rest')) {
        return new WP_Error('invalid_nonce', 'Invalid security token', ['status' => 403]);
    }

    // Check capability
    if (!current_user_can('edit_posts')) {
        return new WP_Error('insufficient_permissions', 'You do not have permission to generate content', ['status' => 403]);
    }

    return true;
}
```
[Source: PRD prd.md#security]

**Service Dependency Injection:**
```php
class ContentGenerationService {
    public function __construct(
        private OpenAIService $openaiService,
        private PromptTemplateEngine $promptEngine,
        private CostTrackingService $costTracking
    ) {}
}
```
[Source: architecture.md#plugin-architecture]

**Integration with Other Stories:**
- Depends on Story 2.1 (OpenAIService)
- Depends on Story 2.2 (PromptTemplateEngine)
- Integrates with Story 2.5 (CostTrackingService for logging)
- Used by Story 2.4 (Bulk generation)

### Testing

**Test File Location:**
- `tests/php/Controllers/GenerationControllerTest.php`
- `tests/php/Services/ContentGenerationServiceTest.php`

**Testing Framework:**
- PHPUnit 9.x with WordPress test framework
- Use `WP_UnitTestCase` for WordPress-aware tests
- Mock OpenAI responses to avoid real API calls
[Source: architecture.md#tech-stack]

**Test Coverage Requirements:**
- Verify REST route registered correctly
- Test successful generation for all 12 block types
- Test post validation (exists, correct type)
- Test block type validation (valid enum)
- Test permission checks (capability, nonce)
- Test error responses return correct status codes
- Mock OpenAI service to return predictable content
- Verify ACF fields updated with generated content
- Verify response includes all metadata (tokens, cost, time)
- Test content parsing for simple and repeater fields
- Test generation status updated correctly
[Source: PRD prd.md#testing-requirements]

**Coding Standards:**
- Follow WordPress Coding Standards (WPCS)
- Run PHP_CodeSniffer: `composer run phpcs`
- All files must have ABSPATH guard: `defined('ABSPATH') || exit;`
- Type hints for all method parameters and return types
[Source: architecture.md#code-quality-php]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-07 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*This section will be populated by QA Agent after story completion*
