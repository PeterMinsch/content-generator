# Story 9.3: Review Fetch Service with Auto-Refresh

**Epic:** 9 - Automated Review Integration
**Status:** Draft

---

## Story

**As a** content manager,
**I want** reviews automatically fetched and cached when needed,
**so that** review blocks always have fresh data without manual intervention

---

## Acceptance Criteria

1. **ReviewFetchService Orchestration**
   - Service class `ReviewFetchService` coordinates review fetching from Google API
   - Method: `getReviews(int $limit = 10, bool $force_refresh = false): array`
   - Dependency injection: GoogleBusinessService and ReviewRepository injected via constructor
   - Service checks cache age before deciding to fetch from API
   - Returns array of review data (from cache or fresh from API)

2. **Cache Age Validation Logic**
   - Before fetching, check if cache needs refresh using `ReviewRepository::needsRefresh()`
   - Default cache lifetime: 30 days
   - If cache fresh (< 30 days old), return cached reviews from database
   - If cache stale (≥ 30 days) or empty, fetch from Google API
   - Force refresh parameter bypasses cache check (always fetches from API)

3. **API Fetching and Storage**
   - When refresh needed, call `GoogleBusinessService::fetchReviews()`
   - Loop through fetched reviews and save to database via `ReviewRepository::save()`
   - Duplicate reviews automatically skipped (handled by repository UNIQUE constraint)
   - Count new vs duplicate reviews for logging
   - Return reviews after saving to database

4. **Graceful Degradation**
   - If API fails and cache exists, return cached reviews (stale data better than no data)
   - If API fails and no cache, return empty array (don't break page generation)
   - Log all fetch operations: cache hits, API calls, failures
   - Never throw exceptions (always return array, even if empty)

5. **Performance Optimization**
   - Single API call per generation session (cache result in object property)
   - Reviews retrieved once and reused for entire page generation
   - Database queries use LIMIT to prevent large result sets
   - No blocking on API timeouts (30s max wait time)

6. **Logging and Debugging**
   - Log cache age before each operation
   - Log decision: "Using cached reviews" vs "Fetching from API"
   - Log number of reviews fetched and saved
   - Log API failures with error details
   - All logs use "[Review Fetch]" prefix

---

## Tasks / Subtasks

- [ ] **Task 1: Create ReviewFetchService Class** (AC: 1)
  - [ ] Create `includes/Services/ReviewFetchService.php`
  - [ ] Add namespace `SEOGenerator\Services`
  - [ ] Add constructor with GoogleBusinessService and ReviewRepository parameters
  - [ ] Store dependencies in private properties
  - [ ] Add PHPDoc for class and all methods

- [ ] **Task 2: Implement getReviews() Main Method** (AC: 1, 2, 3)
  - [ ] Create public method `getReviews(int $limit = 10, bool $force_refresh = false): array`
  - [ ] Check `$force_refresh` parameter first
  - [ ] If not forced, call `ReviewRepository::needsRefresh(30)`
  - [ ] If cache fresh, call `ReviewRepository::getTopRated($limit)` and return
  - [ ] If cache stale or forced, call `fetchAndStoreReviews()`
  - [ ] After fetching, call `ReviewRepository::getTopRated($limit)` and return
  - [ ] Add logging for all branches

- [ ] **Task 3: Implement fetchAndStoreReviews() Helper** (AC: 3, 4)
  - [ ] Create private method `fetchAndStoreReviews(): int`
  - [ ] Call `GoogleBusinessService::fetchReviews()`
  - [ ] Check if result is empty (API failure or no reviews)
  - [ ] Loop through each review and call `ReviewRepository::save()`
  - [ ] Track count of new reviews (save() returned ID > 0)
  - [ ] Track count of duplicates (save() returned 0)
  - [ ] Log: "Saved X new reviews, skipped Y duplicates"
  - [ ] Return count of new reviews saved

- [ ] **Task 4: Implement Graceful Degradation** (AC: 4)
  - [ ] In `getReviews()`, wrap API fetch in try-catch (defensive)
  - [ ] If `fetchAndStoreReviews()` returns 0 (API failed), check if cache exists
  - [ ] Call `ReviewRepository::getAll(1)` to check if any reviews in cache
  - [ ] If cache exists, log "API failed, using stale cache" and return cached reviews
  - [ ] If no cache, log "API failed, no cache available" and return empty array

- [ ] **Task 5: Add Request-Scoped Caching** (AC: 5)
  - [ ] Add private property `$cached_reviews = null`
  - [ ] At start of `getReviews()`, check if `$cached_reviews` is set
  - [ ] If set, return cached value immediately (skip all logic)
  - [ ] Before returning from `getReviews()`, store result in `$cached_reviews`
  - [ ] This prevents multiple API/DB calls in single request

- [ ] **Task 6: Add Comprehensive Logging** (AC: 6)
  - [ ] At start of `getReviews()`, log cache age: "Cache age: X days"
  - [ ] Log decision: "Using cached reviews" or "Fetching from Google API"
  - [ ] Log force refresh: "Force refresh requested"
  - [ ] Log fetch results: "Fetched X reviews, saved Y new"
  - [ ] Log API failures: "Google API error: {message}"
  - [ ] Log graceful degradation: "Using stale cache (X days old)"
  - [ ] All logs use `error_log()` with "[Review Fetch]" prefix

- [ ] **Task 7: Wire Up Dependency Injection** (AC: 1)
  - [ ] Service instantiation in `Plugin::getInstance()` or where needed
  - [ ] Create GoogleBusinessService instance
  - [ ] Create ReviewRepository instance
  - [ ] Pass both to ReviewFetchService constructor
  - [ ] Store service instance for reuse (singleton pattern)

- [ ] **Task 8: Add Unit Tests** (AC: All)
  - [ ] Test getReviews() returns cached reviews when cache fresh
  - [ ] Test getReviews() fetches from API when cache stale
  - [ ] Test getReviews() forces API fetch when force_refresh=true
  - [ ] Test fetchAndStoreReviews() saves new reviews to database
  - [ ] Test fetchAndStoreReviews() skips duplicate reviews
  - [ ] Test graceful degradation: API fails, returns stale cache
  - [ ] Test graceful degradation: API fails, no cache, returns empty
  - [ ] Test request-scoped caching prevents duplicate calls
  - [ ] Mock GoogleBusinessService and ReviewRepository

---

## Dev Notes

### Feature Context

This story orchestrates the review fetching workflow for Epic 9 (Automated Review Integration). It sits between the Google API integration (Story 9.2) and page generation (Story 9.4), providing intelligent caching and error handling.

**Key Design Decisions:**
- Cache-first approach reduces API calls and improves performance
- 30-day cache lifetime balances freshness with API quota conservation
- Graceful degradation ensures page generation never fails due to API issues
- Request-scoped caching prevents duplicate work in single page generation

**Workflow:**
1. Page generation requests reviews
2. ReviewFetchService checks cache age
3. If fresh: return cached data (fast path)
4. If stale: fetch from API → save → return (slow path)
5. If API fails: return stale cache or empty array (fallback path)

### Previous Story Insights

From Story 9.1 (Review Database):
- ReviewRepository provides `needsRefresh()`, `getTopRated()`, `save()` methods
- Repository handles duplicate detection via UNIQUE constraint
- Cache age calculated from `last_fetched_at` field

From Story 9.2 (Google API):
- GoogleBusinessService provides `fetchReviews()` method
- Returns array of normalized reviews or empty array on error
- All errors logged with details

From Epic 5 (Image Library):
- Service layer orchestrates complex workflows
- Dependency injection makes services testable
- Graceful degradation prevents user-facing errors

### Data Models

**ReviewFetchService Return Format:**
```php
[
    [
        'id' => 123,
        'source' => 'google',
        'external_review_id' => 'ChZDSUhN...',
        'reviewer_name' => 'Sarah Johnson',
        'reviewer_avatar_url' => 'https://...',
        'rating' => '5.0',
        'review_text' => 'Excellent service!',
        'review_date' => '2025-09-15 10:30:00',
        'last_fetched_at' => '2025-10-15 14:22:00'
    ],
    // ... more reviews
]
```

**Cache Decision Logic:**
```
Cache Age < 30 days AND NOT force_refresh
    → Return cached reviews (fast)

Cache Age >= 30 days OR force_refresh OR empty cache
    → Fetch from API → Save → Return fresh reviews (slow)

API Fetch Failed AND cache exists
    → Return stale cached reviews (degraded)

API Fetch Failed AND no cache
    → Return empty array (fallback)
```

[Source: Epic 9 - Story 9.3 Requirements]

### Plugin Architecture & Patterns

**Service Orchestration Pattern**
High-level services coordinate lower-level services [Source: architecture.md#Service Layer]:
- ReviewFetchService = orchestrator (decides when to fetch)
- GoogleBusinessService = data provider (fetches from API)
- ReviewRepository = data storage (saves/retrieves from DB)

**Dependency Injection**
Services injected via constructor for testability [Source: architecture.md#Dependency Injection]:
```php
class ReviewFetchService {
    public function __construct(
        GoogleBusinessService $googleService,
        ReviewRepository $repository
    ) {
        $this->googleService = $googleService;
        $this->repository = $repository;
    }
}
```

**Graceful Degradation**
Fail gracefully instead of throwing errors [Source: WordPress best practices]:
- Return empty array instead of null (consistent return type)
- Log errors but don't expose to users
- Use stale data if fresh data unavailable

### File Locations

Based on Unified Project Structure [Source: architecture.md#Unified Project Structure]:

**PHP Classes:**
- New: `includes/Services/ReviewFetchService.php`
- Depends on: `includes/Services/GoogleBusinessService.php` (Story 9.2)
- Depends on: `includes/Repositories/ReviewRepository.php` (Story 9.1)

### Component Specifications

**ReviewFetchService Class**
Location: `includes/Services/ReviewFetchService.php`

```php
<?php
namespace SEOGenerator\Services;

use SEOGenerator\Repositories\ReviewRepository;

/**
 * Review Fetch Service with automatic caching and refresh
 *
 * Orchestrates review fetching from Google Business Profile API with intelligent
 * caching to minimize API calls while keeping data reasonably fresh.
 *
 * @package SEOGenerator\Services
 */
class ReviewFetchService {

    /**
     * Google Business API integration service
     * @var GoogleBusinessService
     */
    private $googleService;

    /**
     * Review data repository
     * @var ReviewRepository
     */
    private $repository;

    /**
     * Request-scoped cache (prevents duplicate fetches in same request)
     * @var array|null
     */
    private $cached_reviews = null;

    /**
     * Constructor
     *
     * @param GoogleBusinessService $googleService Google API integration
     * @param ReviewRepository $repository Review data repository
     */
    public function __construct(
        GoogleBusinessService $googleService,
        ReviewRepository $repository
    ) {
        $this->googleService = $googleService;
        $this->repository = $repository;
    }

    /**
     * Get reviews (from cache or fresh from API)
     *
     * @param int $limit Maximum number of reviews to return (default: 10)
     * @param bool $force_refresh Force API fetch even if cache fresh (default: false)
     * @return array Array of review data (empty if no reviews available)
     */
    public function getReviews(int $limit = 10, bool $force_refresh = false): array {
        // Return request-scoped cache if available
        if ($this->cached_reviews !== null) {
            error_log('[Review Fetch] Using request-scoped cache');
            return array_slice($this->cached_reviews, 0, $limit);
        }

        // Check cache age
        $cache_age = $this->repository->getCacheAge();
        error_log(sprintf('[Review Fetch] Cache age: %d days', $cache_age));

        // Determine if refresh needed
        $needs_refresh = $force_refresh || $this->repository->needsRefresh(30);

        if ($force_refresh) {
            error_log('[Review Fetch] Force refresh requested');
        }

        // Use cached reviews if fresh
        if (!$needs_refresh) {
            error_log('[Review Fetch] Using cached reviews');
            $reviews = $this->repository->getTopRated($limit);
            $this->cached_reviews = $reviews;
            return $reviews;
        }

        // Fetch fresh reviews from API
        error_log('[Review Fetch] Fetching from Google API (cache stale or empty)');

        $new_count = $this->fetchAndStoreReviews();

        // Graceful degradation: if fetch failed, use stale cache
        if ($new_count === 0) {
            error_log('[Review Fetch] API fetch failed, checking for stale cache');

            $stale_reviews = $this->repository->getAll(1);
            if (!empty($stale_reviews)) {
                error_log(sprintf('[Review Fetch] Using stale cache (%d days old)', $cache_age));
                $reviews = $this->repository->getTopRated($limit);
                $this->cached_reviews = $reviews;
                return $reviews;
            }

            error_log('[Review Fetch] No cache available, returning empty array');
            return [];
        }

        // Return fresh reviews
        $reviews = $this->repository->getTopRated($limit);
        $this->cached_reviews = $reviews;

        return $reviews;
    }

    /**
     * Fetch reviews from Google API and store in database
     *
     * @return int Number of new reviews saved (0 if fetch failed)
     */
    private function fetchAndStoreReviews(): int {
        // Fetch from Google API
        $reviews = $this->googleService->fetchReviews();

        if (empty($reviews)) {
            error_log('[Review Fetch] Google API returned no reviews');
            return 0;
        }

        // Save to database
        $new_count = 0;
        $duplicate_count = 0;

        foreach ($reviews as $review) {
            $result = $this->repository->save($review);

            if ($result > 0) {
                $new_count++;
            } else {
                $duplicate_count++;
            }
        }

        error_log(sprintf(
            '[Review Fetch] Saved %d new reviews, skipped %d duplicates',
            $new_count,
            $duplicate_count
        ));

        return $new_count;
    }
}
```

[Source: Epic 9 - Story 9.3 Requirements + Service Layer Patterns]

**Service Instantiation (Plugin.php)**
Location: `includes/Plugin.php` (or wherever services are initialized)

```php
/**
 * Get ReviewFetchService instance (singleton)
 *
 * @return ReviewFetchService
 */
public static function getReviewFetchService(): ReviewFetchService {
    static $instance = null;

    if ($instance === null) {
        $googleService = new GoogleBusinessService();
        $repository = new ReviewRepository();
        $instance = new ReviewFetchService($googleService, $repository);
    }

    return $instance;
}
```

### API Specifications

**ReviewFetchService::getReviews()**
```php
/**
 * Get reviews with intelligent caching
 *
 * @param int $limit Maximum number of reviews (default: 10)
 * @param bool $force_refresh Bypass cache, always fetch fresh (default: false)
 * @return array Review data from cache or API
 */
public function getReviews(int $limit = 10, bool $force_refresh = false): array
```

**Usage Examples:**

```php
// Get top 5 reviews (uses cache if fresh)
$service = Plugin::getReviewFetchService();
$reviews = $service->getReviews(5);

// Force fresh fetch from API
$reviews = $service->getReviews(10, true);

// Get default 10 reviews
$reviews = $service->getReviews();
```

### Technical Constraints

**Cache Lifetime**
- Default: 30 days
- Configurable via `ReviewRepository::needsRefresh($max_days)` parameter
- Balance between freshness and API quota conservation

**Performance Requirements**
- Cache hit: < 100ms (database query only)
- Cache miss: < 10s (includes API call)
- Request-scoped cache: instant (no DB/API calls)

**Error Handling Philosophy**
- Never throw exceptions (page generation must not break)
- Always return array (empty if no data available)
- Log all errors for debugging
- Prefer stale data over no data

### Integration Points

**Hook 1: Called by ContentGenerationService (Story 9.4)**
Location: `includes/Services/ContentGenerationService.php`

```php
// During page generation with review block
$reviewFetchService = Plugin::getReviewFetchService();
$reviews = $reviewFetchService->getReviews(5);

// Store in post meta
update_post_meta($post_id, '_seo_reviews_data', wp_json_encode($reviews));
```

**Hook 2: Dependency Injection**
Location: `includes/Plugin.php` (or service container)

```php
// Instantiate dependencies
$googleService = new GoogleBusinessService();
$repository = new ReviewRepository();

// Inject into ReviewFetchService
$reviewFetchService = new ReviewFetchService($googleService, $repository);
```

**Hook 3: Debug Logging**
Location: `wp-content/debug.log`

All operations logged for troubleshooting:
```
[2025-10-15 14:22:01] [Review Fetch] Cache age: 5 days
[2025-10-15 14:22:01] [Review Fetch] Using cached reviews
[2025-10-15 14:25:10] [Review Fetch] Cache age: 35 days
[2025-10-15 14:25:10] [Review Fetch] Fetching from Google API (cache stale or empty)
[2025-10-15 14:25:13] [Review Fetch] Saved 3 new reviews, skipped 20 duplicates
```

### Project Structure Notes

The plugin follows service orchestration pattern [Source: architecture.md#Service Layer]:
- High-level services (ReviewFetchService) coordinate low-level services
- Dependency injection enables easy testing with mocks
- Singleton pattern (via Plugin class) ensures single instance per request

No admin UI needed - purely backend orchestration.

---

## Testing

### Testing Standards

**Framework:** PHPUnit 9.x with mocking library [Source: architecture.md#Tech Stack - Backend Testing]

**Test Location:**
- Unit tests: `tests/php/Services/ReviewFetchServiceTest.php` (new)
- Integration tests: `tests/php/Integration/ReviewCachingTest.php` (new)

**Standards:** Mock dependencies (GoogleBusinessService, ReviewRepository) for unit tests

**Coverage:** Test all cache scenarios, API failures, and graceful degradation

### Test Cases

**Unit Test: Cache Fresh - Returns Cached Reviews**
```php
public function test_get_reviews_returns_cached_when_fresh() {
    // Mock repository: cache is fresh (10 days old)
    $repository = $this->createMock(ReviewRepository::class);
    $repository->method('getCacheAge')->willReturn(10);
    $repository->method('needsRefresh')->willReturn(false);
    $repository->method('getTopRated')->willReturn([
        ['id' => 1, 'rating' => 5.0, 'reviewer_name' => 'John'],
    ]);

    // Mock Google service (should not be called)
    $googleService = $this->createMock(GoogleBusinessService::class);
    $googleService->expects($this->never())->method('fetchReviews');

    $service = new ReviewFetchService($googleService, $repository);
    $reviews = $service->getReviews(5);

    $this->assertCount(1, $reviews);
    $this->assertEquals('John', $reviews[0]['reviewer_name']);
}
```

**Unit Test: Cache Stale - Fetches from API**
```php
public function test_get_reviews_fetches_when_stale() {
    // Mock repository: cache is stale (35 days old)
    $repository = $this->createMock(ReviewRepository::class);
    $repository->method('getCacheAge')->willReturn(35);
    $repository->method('needsRefresh')->willReturn(true);
    $repository->method('save')->willReturn(123); // Successful save
    $repository->method('getTopRated')->willReturn([
        ['id' => 123, 'rating' => 5.0, 'reviewer_name' => 'Fresh'],
    ]);

    // Mock Google service: returns fresh reviews
    $googleService = $this->createMock(GoogleBusinessService::class);
    $googleService->method('fetchReviews')->willReturn([
        ['reviewer_name' => 'Fresh', 'rating' => 5.0, ...],
    ]);

    $service = new ReviewFetchService($googleService, $repository);
    $reviews = $service->getReviews(5);

    $this->assertCount(1, $reviews);
    $this->assertEquals('Fresh', $reviews[0]['reviewer_name']);
}
```

**Unit Test: Force Refresh Bypasses Cache**
```php
public function test_force_refresh_bypasses_cache() {
    // Mock repository: cache is fresh but force_refresh=true
    $repository = $this->createMock(ReviewRepository::class);
    $repository->method('getCacheAge')->willReturn(5);
    $repository->method('save')->willReturn(124);
    $repository->method('getTopRated')->willReturn([
        ['id' => 124, 'rating' => 4.5, 'reviewer_name' => 'Forced'],
    ]);

    // Mock Google service: should be called despite fresh cache
    $googleService = $this->createMock(GoogleBusinessService::class);
    $googleService->expects($this->once())->method('fetchReviews')->willReturn([
        ['reviewer_name' => 'Forced', 'rating' => 4.5, ...],
    ]);

    $service = new ReviewFetchService($googleService, $repository);
    $reviews = $service->getReviews(5, true); // force_refresh=true

    $this->assertCount(1, $reviews);
}
```

**Unit Test: API Fails - Returns Stale Cache**
```php
public function test_api_fails_returns_stale_cache() {
    // Mock repository: cache stale, but has data
    $repository = $this->createMock(ReviewRepository::class);
    $repository->method('getCacheAge')->willReturn(40);
    $repository->method('needsRefresh')->willReturn(true);
    $repository->method('getAll')->willReturn([['id' => 1]]); // Cache exists
    $repository->method('getTopRated')->willReturn([
        ['id' => 1, 'rating' => 5.0, 'reviewer_name' => 'Stale'],
    ]);

    // Mock Google service: API fails (returns empty)
    $googleService = $this->createMock(GoogleBusinessService::class);
    $googleService->method('fetchReviews')->willReturn([]);

    $service = new ReviewFetchService($googleService, $repository);
    $reviews = $service->getReviews(5);

    // Should return stale cache instead of empty
    $this->assertCount(1, $reviews);
    $this->assertEquals('Stale', $reviews[0]['reviewer_name']);
}
```

**Unit Test: API Fails, No Cache - Returns Empty**
```php
public function test_api_fails_no_cache_returns_empty() {
    // Mock repository: no cache exists
    $repository = $this->createMock(ReviewRepository::class);
    $repository->method('getCacheAge')->willReturn(0);
    $repository->method('needsRefresh')->willReturn(true);
    $repository->method('getAll')->willReturn([]); // No cache

    // Mock Google service: API fails
    $googleService = $this->createMock(GoogleBusinessService::class);
    $googleService->method('fetchReviews')->willReturn([]);

    $service = new ReviewFetchService($googleService, $repository);
    $reviews = $service->getReviews(5);

    $this->assertEmpty($reviews);
}
```

**Unit Test: Duplicate Detection During Save**
```php
public function test_save_skips_duplicates() {
    // Mock repository: save() returns 0 for duplicates
    $repository = $this->createMock(ReviewRepository::class);
    $repository->method('getCacheAge')->willReturn(35);
    $repository->method('needsRefresh')->willReturn(true);
    $repository->method('save')->will($this->onConsecutiveCalls(
        125, // First review: new
        0,   // Second review: duplicate
        126  // Third review: new
    ));
    $repository->method('getTopRated')->willReturn([]);

    // Mock Google service: returns 3 reviews
    $googleService = $this->createMock(GoogleBusinessService::class);
    $googleService->method('fetchReviews')->willReturn([
        ['external_review_id' => 'abc1', ...],
        ['external_review_id' => 'abc2', ...], // Duplicate
        ['external_review_id' => 'abc3', ...],
    ]);

    $service = new ReviewFetchService($googleService, $repository);
    $service->getReviews(5);

    // Verify save() was called 3 times
    // 2 new reviews, 1 duplicate skipped (logged but not saved again)
}
```

**Integration Test: Full Workflow**
```php
public function test_full_review_fetching_workflow() {
    // Real repository (uses test database)
    $repository = new ReviewRepository();
    $repository->deleteAll(); // Clear before test

    // Mock Google service with test data
    $googleService = $this->createMock(GoogleBusinessService::class);
    $googleService->method('fetchReviews')->willReturn([
        [
            'source' => 'google',
            'external_review_id' => 'test123',
            'reviewer_name' => 'Test User',
            'rating' => 5.0,
            'review_text' => 'Great!',
            'review_date' => '2025-09-20 10:00:00',
        ],
    ]);

    $service = new ReviewFetchService($googleService, $repository);

    // First call: cache empty, fetches from API
    $reviews = $service->getReviews(5);
    $this->assertCount(1, $reviews);

    // Second call: cache fresh, returns cached
    $reviews2 = $service->getReviews(5);
    $this->assertCount(1, $reviews2);
    $this->assertEquals($reviews[0]['id'], $reviews2[0]['id']); // Same review
}
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-15 | 1.0 | Initial story creation | Bob (Scrum Master) |

---

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*To be completed by Dev Agent*

### Debug Log References

*To be completed by Dev Agent*

### Completion Notes List

*To be completed by Dev Agent*

### File List

*To be completed by Dev Agent*

---

## QA Results

*This section will be populated by the QA Agent after testing*
