# Story 6.5: Add Background Generation Queue

## Status

Ready for Review

## Story

**As a** site administrator,
**I want** imported pages auto-generated in the background,
**So that** I don't have to manually trigger generation for each page

## Acceptance Criteria

1. Import options include radio buttons:
   - "Create drafts only" (manual generation later)
   - "Auto-generate content" (queue background jobs)
2. If "Auto-generate content" selected:
   - Each imported page queued for generation
   - Jobs scheduled 3 minutes apart to avoid rate limits
   - Generation happens via WordPress Cron
3. Cron job `seo_generate_queued_page` processes one page:
   - Calls `generateAllBlocks()` for the post
   - Updates post status to "pending review" after successful generation
   - Logs any errors
4. Admin can view queue status:
   - Pending jobs count
   - Currently processing job
   - Estimated completion time
5. Queue can be cleared/paused by admin

## Tasks / Subtasks

- [x] Task 1: Add import options UI (AC: 1)
  - [x] Update `templates/admin/import.php` with options section
  - [x] Add radio button group: "generation_mode"
  - [x] Option 1: "drafts_only" - "Create drafts only (generate manually later)"
  - [x] Option 2: "auto_generate" - "Auto-generate content in background"
  - [x] Default selection: "drafts_only"
  - [x] Add help text explaining background generation and rate limits

- [x] Task 2: Save import options to transient (AC: 1)
  - [x] Update ImportPage to capture generation_mode from form
  - [x] Store in transient: set_transient("import_options_{$user_id}", $options, HOUR_IN_SECONDS)
  - [x] Options structure: ['generation_mode' => 'auto_generate', 'check_duplicates' => true]
  - [x] Pass options to ImportService

- [x] Task 3: Create GenerationQueue service (AC: 2, 3, 5)
  - [x] Create `includes/Services/GenerationQueue.php`
  - [x] Define GenerationQueue class following Service Layer pattern
  - [x] Add methods: queuePost($post_id), getQueuedPosts(), clearQueue(), pauseQueue(), resumeQueue()
  - [x] Store queue in wp_options: 'seo_generation_queue'
  - [x] Queue structure: ['post_id' => 123, 'scheduled_time' => timestamp, 'status' => 'pending']

- [x] Task 4: Implement queue scheduling logic (AC: 2)
  - [x] After post creation in ImportService, check if auto_generate enabled
  - [x] Call GenerationQueue::queuePost($post_id) for each created post
  - [x] Calculate scheduled time: base_time + (index * 180 seconds)
  - [x] Use wp_schedule_single_event() to schedule cron job
  - [x] Hook: 'seo_generate_queued_page'
  - [x] Pass post_id as argument to cron job

- [x] Task 5: Register WordPress Cron hook (AC: 3)
  - [x] In main plugin file, add action: add_action('seo_generate_queued_page', [$this, 'processQueuedPage'])
  - [x] Create processQueuedPage($post_id) method
  - [x] Verify post exists and is still draft status
  - [x] Call GenerationService::generateAllBlocks($post_id)
  - [x] Update queue status to 'processing' before generation
  - [x] Update queue status to 'completed' after generation

- [x] Task 6: Implement generateAllBlocks() method (AC: 3)
  - [x] Update GenerationService or create new method
  - [x] Loop through all 12 block types
  - [x] Call generateBlock($post_id, $block_type) for each
  - [x] Track successful and failed block generations
  - [x] Continue to next block if one fails (don't stop entire generation)
  - [x] Return summary: ['success' => true, 'blocks_generated' => 11, 'blocks_failed' => 1]

- [x] Task 7: Update post status after generation (AC: 3)
  - [x] After successful generateAllBlocks(), update post status
  - [x] Use wp_update_post(): set post_status to 'pending'
  - [x] Only update if all blocks generated successfully
  - [x] If some blocks failed, keep as 'draft' and log warning
  - [x] Add post meta: '_auto_generated' => true, '_generation_date' => current_time('mysql')

- [x] Task 8: Implement error handling and logging (AC: 3)
  - [x] Wrap generation in try/catch block
  - [x] Catch OpenAI API errors (rate limit, timeout, invalid key)
  - [x] Log errors to WordPress debug.log with post ID and error message
  - [x] Update queue item status to 'failed' with error message
  - [x] Send admin email notification if generation fails (optional)
  - [x] Don't retry automatically (admin can manually retry)

- [x] Task 9: Create queue status admin page (AC: 4)
  - [x] Create `includes/Admin/QueueStatusPage.php`
  - [x] Register admin menu: "Content Generator > Generation Queue"
  - [x] Template: `templates/admin/queue-status.php`
  - [x] Display queue statistics: pending, processing, completed, failed counts
  - [x] Show list of queued posts with status and scheduled time
  - [x] Add "Clear Queue" and "Pause Queue" buttons

- [x] Task 10: Display pending jobs list (AC: 4)
  - [x] Query queue for pending jobs: status = 'pending' or 'processing'
  - [x] Display table with columns: Post Title, Scheduled Time, Status, Actions
  - [x] Show "Processing..." indicator for currently running job
  - [x] Add "Cancel" button for individual jobs (remove from queue)
  - [x] Paginate list (20 jobs per page)

- [x] Task 11: Calculate estimated completion time (AC: 4)
  - [x] Count pending jobs in queue
  - [x] Calculate time: pending_count * 3 minutes (average per job)
  - [x] Add time to last scheduled job timestamp
  - [x] Display: "Estimated completion: October 9, 2025 at 3:45 PM"
  - [x] Update estimate in real-time (AJAX refresh every 30 seconds)

- [x] Task 12: Implement queue control actions (AC: 5)
  - [x] Create clearQueue() method: delete all pending jobs, cancel scheduled cron events
  - [x] Create pauseQueue() method: set option 'seo_queue_paused' = true
  - [x] Create resumeQueue() method: set option 'seo_queue_paused' = false
  - [x] Check paused status in processQueuedPage() - skip if paused
  - [x] Add admin notices after actions: "Queue cleared", "Queue paused", "Queue resumed"

- [x] Task 13: Add real-time queue updates (AC: 4)
  - [x] Create AJAX endpoint: wp_ajax_queue_status
  - [x] Return JSON: {pending: 5, processing: 1, completed: 12, failed: 2, estimated_time: '2025-10-09 15:45:00'}
  - [x] Frontend polls endpoint every 30 seconds
  - [x] Update queue statistics without page reload
  - [x] Show notification when queue completes

- [x] Task 14: Handle WordPress Cron limitations (AC: 2, 3)
  - [x] Add admin notice explaining WordPress Cron requires site traffic
  - [x] Recommend server cron for production: 'wp cron event run --due-now'
  - [x] Document WP Cron limitations in help text
  - [x] Add option to disable WP Cron and use server cron instead
  - [x] Provide WP-CLI command for manual queue processing

- [x] Task 15: Integrate with ImportService (AC: 2)
  - [x] Update ImportService::createPost() method
  - [x] After successful post creation, check generation_mode option
  - [x] If 'auto_generate', call GenerationQueue::queuePost($post_id, $index)
  - [x] Pass $index for scheduling offset calculation
  - [x] Include queue summary in import report: "X posts queued for generation"

- [x] Task 16: Add rate limit protection (AC: 2)
  - [x] Enforce minimum 3-minute spacing between jobs
  - [x] Track last generation timestamp in options
  - [x] If job starts before 3 minutes elapsed, reschedule for later
  - [x] Add configurable rate limit setting (default 180 seconds)
  - [x] Log rate limit warnings

- [x] Task 17: Create queue management WP-CLI commands (AC: 5)
  - [x] Create `includes/CLI/QueueCommand.php`
  - [x] Command: `wp seo-generator queue list` - show all queued jobs
  - [x] Command: `wp seo-generator queue process` - process next pending job
  - [x] Command: `wp seo-generator queue clear` - clear all pending jobs
  - [x] Command: `wp seo-generator queue status` - show queue statistics
  - [x] Register commands with WP_CLI::add_command()

- [x] Task 18: Write unit tests for GenerationQueue (AC: 2, 3, 5)
  - [x] Create `tests/Services/GenerationQueueTest.php`
  - [x] Test queuePost() adds job to queue
  - [x] Test job scheduling with 3-minute offset
  - [x] Test getQueuedPosts() returns pending jobs
  - [x] Test clearQueue() removes all jobs and cancels cron events
  - [x] Test pauseQueue() and resumeQueue() set/unset paused flag
  - [x] Test processQueuedPage() generates content
  - [x] Test post status updated to 'pending' after generation
  - [x] Test error handling when generation fails
  - [x] Mock wp_schedule_single_event() and GenerationService calls

- [x] Task 19: Write integration tests for cron processing (AC: 3)
  - [x] Create `tests/Cron/GenerationCronTest.php`
  - [x] Test cron hook is registered
  - [x] Test processQueuedPage() is called when cron fires
  - [x] Test generateAllBlocks() processes all 12 blocks
  - [x] Test queue status updates during processing
  - [x] Use WordPress test suite's cron simulation
  - [x] Mock OpenAI API responses

## Dev Notes

### Relevant Architecture Context

**Tech Stack:**
- **WordPress Cron:** wp_schedule_single_event(), wp_clear_scheduled_hook(), wp_next_scheduled()
- **Options API:** get_option(), update_option(), delete_option()
- **WP-CLI:** WP_CLI::add_command() for queue management commands
- **AJAX:** wp_ajax_{action} for real-time status updates
[Source: architecture.md#tech-stack]

**WordPress Cron Scheduling:**
```php
// Schedule single event 3 minutes from now
$timestamp = time() + (3 * 60);
wp_schedule_single_event($timestamp, 'seo_generate_queued_page', [$post_id]);

// Register hook handler
add_action('seo_generate_queued_page', function($post_id) {
    $generator = new GenerationService();
    $generator->processQueuedPage($post_id);
});

// Check if event is scheduled
$next_scheduled = wp_next_scheduled('seo_generate_queued_page', [$post_id]);
if ($next_scheduled) {
    // Event is scheduled for $next_scheduled timestamp
}

// Cancel scheduled event
wp_clear_scheduled_hook('seo_generate_queued_page', [$post_id]);
```
[Source: epic-6-csv-import.md#story-6.5-technical-requirements]

**GenerationQueue Service Class:**
```php
namespace SEOGenerator\Services;

class GenerationQueue {
    const QUEUE_OPTION = 'seo_generation_queue';
    const PAUSED_OPTION = 'seo_queue_paused';
    const RATE_LIMIT_SECONDS = 180; // 3 minutes

    public function queuePost($post_id, $index = 0) {
        // Get current queue
        $queue = get_option(self::QUEUE_OPTION, []);

        // Calculate scheduled time (3 minutes apart)
        $base_time = time();
        $scheduled_time = $base_time + ($index * self::RATE_LIMIT_SECONDS);

        // Add to queue
        $queue[] = [
            'post_id' => $post_id,
            'scheduled_time' => $scheduled_time,
            'status' => 'pending',
            'queued_at' => current_time('mysql'),
        ];

        update_option(self::QUEUE_OPTION, $queue);

        // Schedule WordPress Cron event
        wp_schedule_single_event($scheduled_time, 'seo_generate_queued_page', [$post_id]);

        return true;
    }

    public function getQueuedPosts($status = null) {
        $queue = get_option(self::QUEUE_OPTION, []);

        if ($status) {
            return array_filter($queue, function($item) use ($status) {
                return $item['status'] === $status;
            });
        }

        return $queue;
    }

    public function updateQueueStatus($post_id, $status, $error = null) {
        $queue = get_option(self::QUEUE_OPTION, []);

        foreach ($queue as &$item) {
            if ($item['post_id'] === $post_id) {
                $item['status'] = $status;
                $item['updated_at'] = current_time('mysql');
                if ($error) {
                    $item['error'] = $error;
                }
                break;
            }
        }

        update_option(self::QUEUE_OPTION, $queue);
    }

    public function clearQueue() {
        $queue = get_option(self::QUEUE_OPTION, []);

        // Cancel all scheduled cron events
        foreach ($queue as $item) {
            if ($item['status'] === 'pending') {
                wp_clear_scheduled_hook('seo_generate_queued_page', [$item['post_id']]);
            }
        }

        // Clear queue
        delete_option(self::QUEUE_OPTION);
    }

    public function pauseQueue() {
        update_option(self::PAUSED_OPTION, true);
    }

    public function resumeQueue() {
        delete_option(self::PAUSED_OPTION);
    }

    public function isPaused() {
        return (bool) get_option(self::PAUSED_OPTION, false);
    }

    public function getQueueStats() {
        $queue = get_option(self::QUEUE_OPTION, []);

        return [
            'pending' => count(array_filter($queue, fn($i) => $i['status'] === 'pending')),
            'processing' => count(array_filter($queue, fn($i) => $i['status'] === 'processing')),
            'completed' => count(array_filter($queue, fn($i) => $i['status'] === 'completed')),
            'failed' => count(array_filter($queue, fn($i) => $i['status'] === 'failed')),
            'total' => count($queue),
        ];
    }

    public function getEstimatedCompletion() {
        $pending = $this->getQueuedPosts('pending');

        if (empty($pending)) {
            return null;
        }

        // Get last scheduled time
        $last_scheduled = max(array_column($pending, 'scheduled_time'));

        // Add average generation time (5 minutes per post)
        $estimated = $last_scheduled + (5 * 60);

        return date('Y-m-d H:i:s', $estimated);
    }
}
```
[Source: epic-6-csv-import.md#story-6.5-technical-requirements]

**Process Queued Page (Cron Handler):**
```php
namespace SEOGenerator\Services;

class GenerationService {
    private $queue;

    public function __construct() {
        $this->queue = new GenerationQueue();
    }

    public function processQueuedPage($post_id) {
        // Check if queue is paused
        if ($this->queue->isPaused()) {
            error_log("Queue is paused, skipping post {$post_id}");
            // Reschedule for 5 minutes later
            wp_schedule_single_event(time() + 300, 'seo_generate_queued_page', [$post_id]);
            return;
        }

        // Verify post exists
        $post = get_post($post_id);
        if (!$post || $post->post_type !== 'seo-page') {
            error_log("Post {$post_id} not found or invalid type");
            $this->queue->updateQueueStatus($post_id, 'failed', 'Post not found');
            return;
        }

        // Update status to processing
        $this->queue->updateQueueStatus($post_id, 'processing');

        try {
            // Generate all blocks
            $result = $this->generateAllBlocks($post_id);

            if ($result['success']) {
                // Update post status to pending review
                wp_update_post([
                    'ID' => $post_id,
                    'post_status' => 'pending',
                ]);

                // Add generation metadata
                update_post_meta($post_id, '_auto_generated', true);
                update_post_meta($post_id, '_generation_date', current_time('mysql'));
                update_post_meta($post_id, '_blocks_generated', $result['blocks_generated']);

                // Update queue status
                $this->queue->updateQueueStatus($post_id, 'completed');

                error_log("Successfully generated content for post {$post_id}");
            } else {
                throw new \Exception('Generation failed: ' . $result['error']);
            }
        } catch (\Exception $e) {
            error_log("Failed to generate post {$post_id}: " . $e->getMessage());
            $this->queue->updateQueueStatus($post_id, 'failed', $e->getMessage());
        }
    }

    public function generateAllBlocks($post_id) {
        $block_types = [
            'hero',
            'serp_answer',
            'product_criteria',
            'materials_explained',
            'process',
            'comparison',
            'product_showcase',
            'size_fit',
            'care_warranty',
            'ethics_origin',
            'faqs',
            'cta',
        ];

        $generated = 0;
        $failed = 0;
        $errors = [];

        foreach ($block_types as $block_type) {
            try {
                $result = $this->generateBlock($post_id, $block_type);

                if ($result['success']) {
                    $generated++;
                } else {
                    $failed++;
                    $errors[] = "{$block_type}: " . $result['error'];
                }
            } catch (\Exception $e) {
                $failed++;
                $errors[] = "{$block_type}: " . $e->getMessage();
                error_log("Block generation failed for {$block_type}: " . $e->getMessage());
            }
        }

        return [
            'success' => $failed === 0,
            'blocks_generated' => $generated,
            'blocks_failed' => $failed,
            'errors' => $errors,
        ];
    }

    private function generateBlock($post_id, $block_type) {
        // Implementation from Epic 2
        // Calls OpenAI API and saves to ACF fields
        // Returns ['success' => true/false, 'error' => 'message']
    }
}
```
[Source: epic-6-csv-import.md#story-6.5-technical-requirements]

**Import Options UI:**
```php
<!-- In templates/admin/import.php -->
<div class="import-options">
    <h3><?php _e('Generation Options', 'seo-generator'); ?></h3>

    <fieldset>
        <legend class="screen-reader-text">
            <?php _e('Generation mode', 'seo-generator'); ?>
        </legend>

        <label>
            <input type="radio" name="generation_mode" value="drafts_only" checked>
            <?php _e('Create drafts only (generate content manually later)', 'seo-generator'); ?>
        </label>

        <label>
            <input type="radio" name="generation_mode" value="auto_generate">
            <?php _e('Auto-generate content in background', 'seo-generator'); ?>
        </label>

        <p class="description">
            <?php _e('Background generation processes one page every 3 minutes to respect API rate limits. Requires WordPress Cron or server cron to be active.', 'seo-generator'); ?>
        </p>
    </fieldset>

    <label>
        <input type="checkbox" name="check_duplicates" value="1" checked>
        <?php _e('Skip duplicate posts (check if page with same title exists)', 'seo-generator'); ?>
    </label>
</div>
```
[Source: epic-6-csv-import.md#story-6.5-acceptance-criteria]

**Integration with ImportService:**
```php
// In ImportService::createPost()
private function createPost($row, $headers, $mapping, $index = 0) {
    // ... existing post creation code ...

    if (is_wp_error($post_id)) {
        return $post_id;
    }

    // Save metadata
    $this->saveMetadata($post_id, $row, $headers, $mapping);

    // Queue for generation if auto_generate enabled
    $options = get_transient("import_options_" . get_current_user_id());
    if ($options['generation_mode'] === 'auto_generate') {
        $queue = new GenerationQueue();
        $queue->queuePost($post_id, $index);
    }

    return $post_id;
}
```
[Source: epic-6-csv-import.md#story-6.5-technical-requirements]

**Queue Status Page Template:**
```php
<!-- templates/admin/queue-status.php -->
<div class="wrap">
    <h1><?php _e('Generation Queue', 'seo-generator'); ?></h1>

    <div class="queue-stats">
        <div class="stat-box">
            <span class="count" id="pending-count"><?php echo $stats['pending']; ?></span>
            <span class="label"><?php _e('Pending', 'seo-generator'); ?></span>
        </div>
        <div class="stat-box">
            <span class="count" id="processing-count"><?php echo $stats['processing']; ?></span>
            <span class="label"><?php _e('Processing', 'seo-generator'); ?></span>
        </div>
        <div class="stat-box">
            <span class="count" id="completed-count"><?php echo $stats['completed']; ?></span>
            <span class="label"><?php _e('Completed', 'seo-generator'); ?></span>
        </div>
        <div class="stat-box">
            <span class="count" id="failed-count"><?php echo $stats['failed']; ?></span>
            <span class="label"><?php _e('Failed', 'seo-generator'); ?></span>
        </div>
    </div>

    <p class="estimated-completion" id="estimated-completion">
        <?php if ($estimated): ?>
            <?php printf(__('Estimated completion: %s', 'seo-generator'), $estimated); ?>
        <?php else: ?>
            <?php _e('No pending jobs', 'seo-generator'); ?>
        <?php endif; ?>
    </p>

    <div class="queue-actions">
        <button id="pause-queue" class="button"><?php _e('Pause Queue', 'seo-generator'); ?></button>
        <button id="clear-queue" class="button button-secondary"><?php _e('Clear Queue', 'seo-generator'); ?></button>
    </div>

    <table class="wp-list-table widefat fixed striped">
        <thead>
            <tr>
                <th><?php _e('Post Title', 'seo-generator'); ?></th>
                <th><?php _e('Scheduled Time', 'seo-generator'); ?></th>
                <th><?php _e('Status', 'seo-generator'); ?></th>
                <th><?php _e('Actions', 'seo-generator'); ?></th>
            </tr>
        </thead>
        <tbody id="queue-list">
            <?php foreach ($queue as $item): ?>
                <tr data-post-id="<?php echo $item['post_id']; ?>">
                    <td><?php echo get_the_title($item['post_id']); ?></td>
                    <td><?php echo date('Y-m-d H:i:s', $item['scheduled_time']); ?></td>
                    <td class="status-<?php echo $item['status']; ?>">
                        <?php echo ucfirst($item['status']); ?>
                    </td>
                    <td>
                        <?php if ($item['status'] === 'pending'): ?>
                            <button class="button-link cancel-job" data-post-id="<?php echo $item['post_id']; ?>">
                                <?php _e('Cancel', 'seo-generator'); ?>
                            </button>
                        <?php endif; ?>
                    </td>
                </tr>
            <?php endforeach; ?>
        </tbody>
    </table>
</div>
```
[Source: epic-6-csv-import.md#story-6.5-acceptance-criteria]

**AJAX Queue Status Endpoint:**
```php
// In QueueStatusPage.php
public function handleQueueStatus() {
    check_ajax_referer('seo_queue_nonce', 'nonce');

    if (!current_user_can('edit_posts')) {
        wp_send_json_error(['message' => __('Permission denied.', 'seo-generator')]);
    }

    $queue = new GenerationQueue();
    $stats = $queue->getQueueStats();
    $estimated = $queue->getEstimatedCompletion();

    wp_send_json_success([
        'stats' => $stats,
        'estimated_completion' => $estimated,
        'is_paused' => $queue->isPaused(),
    ]);
}
```
[Source: architecture.md#api-specification-ajax]

**Frontend JavaScript for Real-Time Updates:**
```javascript
// In queue-status.js
let updateInterval;

function startQueueMonitoring() {
    updateInterval = setInterval(updateQueueStatus, 30000); // Every 30 seconds
}

async function updateQueueStatus() {
    try {
        const response = await fetch(ajaxurl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                action: 'queue_status',
                nonce: queueNonce,
            }),
        });

        const result = await response.json();

        if (result.success) {
            // Update stats
            document.getElementById('pending-count').textContent = result.data.stats.pending;
            document.getElementById('processing-count').textContent = result.data.stats.processing;
            document.getElementById('completed-count').textContent = result.data.stats.completed;
            document.getElementById('failed-count').textContent = result.data.stats.failed;

            // Update estimated completion
            const estimatedEl = document.getElementById('estimated-completion');
            if (result.data.estimated_completion) {
                estimatedEl.textContent = `Estimated completion: ${result.data.estimated_completion}`;
            } else {
                estimatedEl.textContent = 'No pending jobs';
            }

            // Show notification if queue completed
            if (result.data.stats.pending === 0 && result.data.stats.processing === 0) {
                clearInterval(updateInterval);
                showNotification('Queue processing complete!');
            }
        }
    } catch (error) {
        console.error('Queue status update failed:', error);
    }
}

document.addEventListener('DOMContentLoaded', startQueueMonitoring);
```
[Source: architecture.md#frontend-patterns]

**WP-CLI Queue Commands:**
```php
namespace SEOGenerator\CLI;

use WP_CLI;

class QueueCommand {
    public function list($args, $assoc_args) {
        $queue = new \SEOGenerator\Services\GenerationQueue();
        $posts = $queue->getQueuedPosts();

        if (empty($posts)) {
            WP_CLI::success('Queue is empty');
            return;
        }

        $table = array_map(function($item) {
            return [
                'Post ID' => $item['post_id'],
                'Title' => get_the_title($item['post_id']),
                'Scheduled' => date('Y-m-d H:i:s', $item['scheduled_time']),
                'Status' => $item['status'],
            ];
        }, $posts);

        WP_CLI\Utils\format_items('table', $table, ['Post ID', 'Title', 'Scheduled', 'Status']);
    }

    public function process($args, $assoc_args) {
        $queue = new \SEOGenerator\Services\GenerationQueue();
        $pending = $queue->getQueuedPosts('pending');

        if (empty($pending)) {
            WP_CLI::success('No pending jobs');
            return;
        }

        $next = array_shift($pending);
        $post_id = $next['post_id'];

        WP_CLI::log("Processing post {$post_id}...");

        $service = new \SEOGenerator\Services\GenerationService();
        $service->processQueuedPage($post_id);

        WP_CLI::success("Post {$post_id} processed");
    }

    public function clear($args, $assoc_args) {
        $queue = new \SEOGenerator\Services\GenerationQueue();
        $queue->clearQueue();
        WP_CLI::success('Queue cleared');
    }

    public function status($args, $assoc_args) {
        $queue = new \SEOGenerator\Services\GenerationQueue();
        $stats = $queue->getQueueStats();

        WP_CLI::line('Queue Status:');
        WP_CLI::line('  Pending: ' . $stats['pending']);
        WP_CLI::line('  Processing: ' . $stats['processing']);
        WP_CLI::line('  Completed: ' . $stats['completed']);
        WP_CLI::line('  Failed: ' . $stats['failed']);
        WP_CLI::line('  Total: ' . $stats['total']);

        $estimated = $queue->getEstimatedCompletion();
        if ($estimated) {
            WP_CLI::line('  Estimated completion: ' . $estimated);
        }
    }
}

// Register commands
if (defined('WP_CLI') && WP_CLI) {
    WP_CLI::add_command('seo-generator queue', 'SEOGenerator\CLI\QueueCommand');
}
```
[Source: architecture.md#wp-cli-integration]

**WordPress Cron Limitations Documentation:**
```
WordPress Cron Limitations:
- WordPress Cron only runs when someone visits your site
- Not suitable for high-volume or time-critical tasks
- May not fire if site has low traffic

Recommendations:
1. For production use, disable WP-Cron and use server cron:
   - Add to wp-config.php: define('DISABLE_WP_CRON', true);
   - Add to server crontab: */5 * * * * wp cron event run --due-now --path=/var/www/html

2. Or use WP-CLI to manually process queue:
   - wp seo-generator queue process

3. Monitor queue status regularly to ensure jobs are processing
```
[Source: epic-6-csv-import.md#story-6.5-risks-mitigations]

**Rate Limit Protection:**
```php
private function enforceRateLimit($post_id) {
    $last_generation = get_option('seo_last_generation_time', 0);
    $current_time = time();
    $elapsed = $current_time - $last_generation;

    if ($elapsed < self::RATE_LIMIT_SECONDS) {
        $wait_time = self::RATE_LIMIT_SECONDS - $elapsed;
        error_log("Rate limit: waiting {$wait_time} seconds before generating post {$post_id}");

        // Reschedule for later
        wp_schedule_single_event($current_time + $wait_time, 'seo_generate_queued_page', [$post_id]);
        return false;
    }

    // Update last generation time
    update_option('seo_last_generation_time', $current_time);
    return true;
}
```
[Source: epic-6-csv-import.md#story-6.5-acceptance-criteria]

**Project Structure:**
```
includes/
  Services/
    GenerationQueue.php     # New file for this story
    GenerationService.php   # Updated with processQueuedPage() and generateAllBlocks()
    ImportService.php       # Updated to queue posts (from Story 6.4)
  Admin/
    QueueStatusPage.php     # New admin page for queue management
  CLI/
    QueueCommand.php        # New WP-CLI commands

templates/
  admin/
    queue-status.php        # New template for queue status page

assets/
  js/
    queue-status.js         # Frontend real-time updates
  css/
    queue-status.css        # Queue status page styles

tests/
  Services/
    GenerationQueueTest.php # New PHPUnit test file
  Cron/
    GenerationCronTest.php  # New cron integration test
```
[Source: architecture.md#unified-project-structure]

### Dependencies

**Previous Stories:**
- **Story 6.4 (Implement Batch Page Creation):** Provides ImportService and post creation
  - ImportService creates draft posts
  - ImportService needs to queue posts after creation
  - Import options transient provides generation_mode setting
  [Source: docs/stories/6.4.batch-page-creation.md]

- **Epic 2 (Core Generation):** Provides GenerationService and block generation
  - GenerationService::generateBlock($post_id, $block_type) exists
  - Needs new generateAllBlocks() method to loop through all 12 blocks
  - API integration already handles OpenAI calls

**Next Stories:**
- **Story 6.6 (Handle Image Downloads):** Can be integrated into queue processing
  - Image download can happen during post creation or generation
  - Independent of queue functionality

- **Story 6.7 (Import History and Logging):** Will track queue results
  - Import history includes auto-generation status
  - Logs queue success/failure counts

### Testing

**Test File Locations:**
- `tests/Services/GenerationQueueTest.php`
- `tests/Cron/GenerationCronTest.php`

**Testing Framework:**
- PHPUnit 9.x with WordPress test suite
- Use WP_UnitTestCase for service tests
- Mock WordPress Cron functions for cron tests
[Source: architecture.md#tech-stack]

**Test Coverage Requirements:**
```php
class GenerationQueueTest extends WP_UnitTestCase {
    public function test_queue_post() {
        // Test post is added to queue with pending status
    }

    public function test_scheduling_with_offset() {
        // Test jobs scheduled 3 minutes apart
    }

    public function test_get_queued_posts() {
        // Test retrieval of all queued posts
    }

    public function test_get_queued_posts_by_status() {
        // Test filtering by status (pending, processing, completed, failed)
    }

    public function test_update_queue_status() {
        // Test status update for specific post
    }

    public function test_clear_queue() {
        // Test all pending jobs removed and cron events cancelled
    }

    public function test_pause_resume_queue() {
        // Test pause and resume functionality
    }

    public function test_queue_stats() {
        // Test getQueueStats() returns correct counts
    }

    public function test_estimated_completion() {
        // Test getEstimatedCompletion() calculates correct time
    }
}

class GenerationCronTest extends WP_UnitTestCase {
    public function test_cron_hook_registered() {
        // Test 'seo_generate_queued_page' hook is registered
    }

    public function test_process_queued_page() {
        // Test processQueuedPage() generates all blocks
    }

    public function test_post_status_updated() {
        // Test post status changed to 'pending' after generation
    }

    public function test_queue_status_updated_to_completed() {
        // Test queue item marked as completed
    }

    public function test_generation_error_handling() {
        // Test queue item marked as failed on error
    }

    public function test_paused_queue_reschedules() {
        // Test job rescheduled when queue is paused
    }

    public function test_generate_all_blocks() {
        // Test generateAllBlocks() calls generateBlock() for all 12 types
    }

    public function test_partial_failure_handling() {
        // Test post remains draft if some blocks fail
    }
}
```
[Source: epic-6-csv-import.md#story-6.5-technical-requirements]

**Coding Standards:**
- Use WordPress PHP Coding Standards (PHPCS with WordPress ruleset)
- Type declarations for all method parameters and return types
- Comprehensive error handling with try/catch
- Internationalized strings with __() function
- Nonce verification for all AJAX endpoints
- Capability checks (edit_posts) for all queue operations
[Source: architecture.md#code-quality-php]

**Manual Testing Checklist:**
- [ ] Import CSV with "Auto-generate content" option selected
- [ ] Verify posts are queued (check wp_options for seo_generation_queue)
- [ ] Verify WordPress Cron events scheduled (use WP Crontrol plugin)
- [ ] Wait for cron to fire (or trigger manually with WP-CLI)
- [ ] Verify first post is generated (check ACF fields populated)
- [ ] Verify post status changed from 'draft' to 'pending'
- [ ] Verify queue status updated to 'completed'
- [ ] Check debug.log for generation logging
- [ ] Navigate to "Content Generator > Generation Queue" page
- [ ] Verify queue statistics displayed (pending, processing, completed, failed)
- [ ] Verify estimated completion time shown
- [ ] Click "Pause Queue" and verify queue stops processing
- [ ] Click "Resume Queue" and verify processing continues
- [ ] Click "Clear Queue" and verify all pending jobs removed
- [ ] Test AJAX real-time updates (stats refresh every 30 seconds)
- [ ] Test WP-CLI commands: wp seo-generator queue list
- [ ] Test WP-CLI commands: wp seo-generator queue status
- [ ] Test WP-CLI commands: wp seo-generator queue process
- [ ] Test WP-CLI commands: wp seo-generator queue clear
- [ ] Simulate generation failure (invalid API key) and verify error handling
- [ ] Verify failed jobs marked as 'failed' with error message

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-09 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None

### Completion Notes

All 19 tasks completed successfully. Background generation queue system fully implemented with:

- Import UI with generation mode options (drafts_only vs auto_generate)
- GenerationQueue service for queue management
- WordPress Cron integration for scheduled background processing
- GenerationService with generateAllBlocks() for processing all 12 block types
- Rate limit protection (3-minute spacing between jobs)
- Queue status admin page with real-time AJAX updates
- WP-CLI commands for queue management (list, process, clear, status, pause, resume)
- Comprehensive PHPUnit test coverage (GenerationQueueTest + GenerationCronTest)
- Full error handling and logging throughout

### File List

**New Files:**
- includes/Services/GenerationQueue.php
- includes/Services/GenerationService.php
- includes/Admin/QueueStatusPage.php
- includes/CLI/QueueCommand.php
- templates/admin/queue-status.php
- assets/js/src/queue-status.js
- assets/js/build/queue-status.js
- assets/css/admin-queue.css
- tests/Services/GenerationQueueTest.php
- tests/Cron/GenerationCronTest.php

**Modified Files:**
- includes/Plugin.php (added cron hook registration + WP-CLI command loading)
- includes/Services/ImportService.php (added queue integration at lines 115-120)
- includes/Admin/ImportPage.php (added import options handling at lines 443-451)
- templates/admin/import.php (added generation options UI at lines 138-168)
- webpack.config.js (added queue-status entry point)

## QA Results

*This section will be populated by QA Agent after story completion*
